# C/C++位操作

## 1 位操作基础

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 0 & 0 == 0<br />0 & 1 == 0<br />1 & 0 == 0<br />1 & 1 == 1   |
| \|   | 或   | 0 \| 0 == 0<br />0 \| 1 == 1<br />1 \| 0 == 1<br />1 \| 1 == 1 |
| ^    | 异或 | 0 ^ 0 == 0<br />0 ^ 1 == 1<br />1 ^ 0 == 1<br />1 ^ 1 == 0   |
| ~    | 取反 | ~0 == 1<br />~1 == 0                                         |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，<br />有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

注意以下几点：

(1) 在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。

(2) 位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。

(3) 对于移位操作，在微软的VC6.0和VS2008编译器/gcc编译器都是采取算术移位即算术移位操作，对于不明确是哪一种移位直接用unsigned类型做移位，算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。

	int a = -15, b = 15;
	printf("%d %d\n", a >> 2, b >> 2);
因为15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4（见注1）。

(4) 位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成int a = 1 << i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 << i) + 1;

(5) 另外位操作还有一些复合操作符，如&=、|=、 ^=、<<=、>>=。
————————————————

## 2 常用操作

其中(1)－(3)是基础

(1) 一个数a , a ^ a == 0

(2) 一个数a, a ^ 0 == a

(3) 判断奇偶 (a & 1)

(4) 交换两个数

```c
void Swap(int &a, int &b)
{
	if (a != b)
	{
		int c = a;
		a = b;
		b = c;
	}
}
```

(5) 正数变负数，负数变正数

整数的计算机表示为补码表示，正数的原码、反码、补码都一样，负数的补码是该负数的绝对值的原码的反码加1，因此变换符号就是正数变成负数，负数变成正数的代码如下:

```c
int SignReversal(int a)
{
	return ~a + 1;

```

(6) 求绝对值

对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反，因此求绝对值的函数如下:

```
int my_abs(int a)
{
	int i = a >> 31;
	return ((a ^ i) - i);
}
```

## 参考文献

无
